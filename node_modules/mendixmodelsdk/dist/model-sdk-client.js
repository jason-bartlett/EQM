"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash = require("lodash");
const internal = require("./sdk/internal");
const config_1 = require("./sdk/config");
const abstract_model_1 = require("./sdk/internal/abstract-model");
const utils_1 = require("./sdk/utils");
/**
 * Client class of the Mendix Model SDK.
 * By instantiating this class with appropriate configuration, you can create and read working copies.
 */
class ModelSdkClientImpl {
    constructor(connectionConfig, modelConstructor) {
        this.connectionConfig = connectionConfig;
        this.modelConstructor = modelConstructor;
        const defaultConfig = {
            endPoint: "https://model.api.mendix.com"
        };
        const sdkConfig = lodash.extend({}, defaultConfig, connectionConfig);
        this.client = sdkConfig.client ||
            new internal.ModelServerClientImpl(sdkConfig.transportation || new internal.RestTransportation(sdkConfig));
    }
    /**
     * Create a new working copy on the model server.
     */
    createWorkingCopy(workingCopyParameters, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.createWorkingCopy(workingCopyParameters, callback, errorCallback);
    }
    /**
     * Create a new working copy on the model server, and reads it for immediate editing.
     */
    createAndOpenWorkingCopy(workingCopyParameters, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.createWorkingCopy(workingCopyParameters, workingCopyInfo => {
            this.openWorkingCopy(workingCopyInfo.id, callback, errorCallback);
        }, errorCallback);
    }
    /**
     * Reads a working copy on the model server so it can be edited.
     */
    openWorkingCopy(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkWorkingCopyId(workingCopyId);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        utils_1.utils.resetAlreadyPrintedWarningsState();
        abstract_model_1.AbstractModel.read(this.client, workingCopyId, this.connectionConfig, new this.modelConstructor(this.client, errorCallback, this.connectionConfig), callback, errorCallback);
    }
    /**
     * Gets meta data of a working copy
     */
    loadWorkingCopyMetaData(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkWorkingCopyId(workingCopyId);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.loadWorkingCopyMetaData(workingCopyId, callback, errorCallback);
    }
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    deleteWorkingCopy(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.deleteWorkingCopy(workingCopyId, callback, errorCallback);
    }
    /**
     * Grants access to the member specified to his/her OpenID on this working copy.
     */
    grantAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.grantAccess(workingCopyId, memberOpenId, callback, errorCallback);
    }
    /**
     * Revokes access of the member specified to his/her OpenID on this working copy.
     */
    revokeAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.revokeAccess(workingCopyId, memberOpenId, callback, errorCallback);
    }
    /**
     * Grants access to the member specified to his/her OpenID to the default working copy of this project.
     */
    grantAccessByProject(projectId, memberOpenId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.grantAccessByProject(projectId, memberOpenId, callback, errorCallback);
    }
    /**
     * Revokes access of the member specified to his/her OpenID to the default working copy of this project.
     */
    revokeAccessByProject(projectId, memberOpenId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.revokeAccessByProject(projectId, memberOpenId, callback, errorCallback);
    }
    /**
     * Returns whether the member specified to his/her OpenID has (been granted) access to this working copy.
     */
    checkAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.checkAccess(workingCopyId, memberOpenId, callback, errorCallback);
    }
    /**
     * Exports this working copy as MPK.
     */
    exportMpk(workingCopyId, outFilePath, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.exportMpk(workingCopyId, outFilePath, callback, errorCallback);
    }
    /**
     * Exports the module with the specified ID as MPK.
     */
    exportModuleMpk(workingCopyId, moduleId, outFilePath, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.exportModuleMpk(workingCopyId, moduleId, outFilePath, callback, errorCallback);
    }
    /**
     * Imports the given module MPK into the working copy with the specified ID.
     */
    importModuleMpk(workingCopyId, mpkPath, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.importModuleMpk(workingCopyId, mpkPath, callback, errorCallback);
    }
    /**
     * Start deploy this working copy and create new job.
     */
    startAppUpdate(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.startAppUpdate(workingCopyId, callback, errorCallback);
    }
    /**
     * Start deploy this working copy and create new job.
     */
    getAppUpdateStatus(workingCopyId, jobId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.getAppUpdateStatus(workingCopyId, jobId, callback, errorCallback);
    }
    getAppEnvironmentStatus(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.getAppEnvironmentStatus(workingCopyId, callback, errorCallback);
    }
    /**
     * Retrieves an array of all working copies you are a member of.
     */
    getMyWorkingCopies(callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.getMyWorkingCopies(callback, errorCallback);
    }
    /**
     * Retrieves the working copy id that the given project ID maps to.
     */
    getWorkingCopyByProject(projectId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.getWorkingCopyByProject(projectId, callback, errorCallback);
    }
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    updateWorkingCopyByProject(projectId, workingCopyId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.updateWorkingCopyByProject(projectId, workingCopyId, callback, errorCallback);
    }
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    deleteWorkingCopyByProject(projectId, callback, errorCallback) {
        config_1.configuration.assertBackendAccess(this.connectionConfig);
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.deleteWorkingCopyByProject(projectId, callback, errorCallback);
    }
    lockWorkingCopy(workingCopyId, lockOptionsOrCallback, callbackOrErrorCallback, errorCallback) {
        let callback;
        let lockOptions;
        if (typeof lockOptionsOrCallback === "function") {
            callback = lockOptionsOrCallback;
            errorCallback = callbackOrErrorCallback;
            lockOptions = { lockType: "bidi" };
        }
        else if (typeof lockOptionsOrCallback === "string") {
            lockOptions = { lockType: lockOptionsOrCallback };
            callback = callbackOrErrorCallback;
        }
        else {
            lockOptions = lockOptionsOrCallback;
            callback = callbackOrErrorCallback;
        }
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.lockWorkingCopy(workingCopyId, lockOptions, callback, errorCallback);
    }
    /**
     * Unlock the working copy (will be unlocked for the currently authenticated openid, will fail if it's locked by another openid)
     */
    unlockWorkingCopy(workingCopyId, callback, errorCallback) {
        config_1.configuration.checkCallbacks(callback, errorCallback);
        this.client.unlockWorkingCopy(workingCopyId, callback, errorCallback);
    }
}
exports.ModelSdkClientImpl = ModelSdkClientImpl;
//# sourceMappingURL=model-sdk-client.js.map