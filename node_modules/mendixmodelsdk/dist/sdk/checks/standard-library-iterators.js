"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const expressions_evaluator_1 = require("./expressions-evaluator");
exports.standardIterators = {
    // (in alphabetic order, for easy lookup:)
    EVERY: every,
    FILTER: filter,
    FIND_FIRST: findFirst,
    MAP: map,
    SOME: some
};
/**
 * Produces an iterator lambda on Booleans that maps undefined values to false.
 */
function normalize(lambda) {
    return lodash_1.flowRight((b) => !!b, lambda);
}
/**
 * A class to capture the state of an iteration which consists of the array of which is iterated,
 * the current index and the current value - which equals array[index] if index is valid and undefined otherwise.
 * It helps in implementing the previous operator (and even more generic offset operators)
 * by updating the iteration state in the current context to it.previous().
 * This is a cleaner way than to keep track of the previous value and passing that to expressions
 * bound in the iterator.
 */
class IterationState {
    constructor(index, array) {
        this.index = index;
        this.array = array;
    }
    value() {
        return this.index !== undefined && ((0 <= this.index) && this.index < this.array.length)
            ? this.array[this.index]
            : undefined;
    }
    previous() {
        return this.index !== undefined && this.index > 0
            ? new IterationState(this.index - 1, this.array)
            : new IterationState(undefined, this.array);
    }
}
exports.IterationState = IterationState;
function every(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return false;
    }
    const fItems = items.map(boundExpr);
    if (fItems.some(expressions_evaluator_1.isNothing)) {
        return false;
    }
    return fItems.every(fItem => !!fItem);
}
function findFirst(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return lodash_1.find(items, normalize(boundExpr));
}
function filter(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return items.filter(normalize(boundExpr));
}
function map(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return items.map(boundExpr).filter(item => item !== undefined);
}
function some(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return false;
    }
    if (items.length === 0) {
        return false;
    }
    const fItems = items.map(boundExpr);
    if (fItems.some(fItem => !!fItem)) {
        return true;
    }
    if (fItems.every(expressions_evaluator_1.isNothing)) {
        return undefined;
    }
    return false;
}
//# sourceMappingURL=standard-library-iterators.js.map