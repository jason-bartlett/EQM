"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const checks_evaluator_1 = require("./checks-evaluator");
const metadata_loaders_1 = require("./metadata-loaders");
const versioning_1 = require("./versioning");
const utils_1 = require("../utils");
function makeChecksResolver(checks = metadata_loaders_1.loadChecks()) {
    const map = {};
    checks.forEach(check => {
        check.allCompatibleTypes.forEach(qualifiedStructureName => {
            let checksList = map[qualifiedStructureName];
            if (!checksList) {
                checksList = map[qualifiedStructureName] = [];
            }
            checksList.push(check);
        });
    });
    return (qualifiedStructureName) => map[qualifiedStructureName];
}
exports.makeChecksResolver = makeChecksResolver;
function runChecksOn(unit, checksResolver, queryResolver) {
    if (!unit.isLoaded) {
        throw new Error("can only run checks on loaded unit");
    }
    const checkTasksPerLevelPerGroup = tasks(unit, checksResolver);
    const allIssues = [];
    // TODO: report unresolved by-name references
    // allIssues.push(reportUnresolvedByNameReferences(unit));
    for (const group in checkTasksPerLevelPerGroup) {
        let stopAfterThisLevel = false;
        const checkTasksPerLevel = checkTasksPerLevelPerGroup[group];
        for (const level in checkTasksPerLevel) {
            if (stopAfterThisLevel) {
                break;
            }
            if (!checkTasksPerLevel[level]) {
                continue;
            }
            for (const task of checkTasksPerLevel[level]) {
                const issues = checks_evaluator_1.evaluateCheckBody(task.checkName, task.checkBody, task.structure, queryResolver);
                if (issues.length > 0) {
                    allIssues.push(issues);
                    // always run all checks of level 0 (no level group) and 1 (1st level group):
                    if (level !== "0") { // (compare with string since for (let level: string...))
                        stopAfterThisLevel = true;
                    }
                }
            }
        }
    }
    return utils_1.utils.flatten(allIssues);
}
exports.runChecksOn = runChecksOn;
const alwaysRunSpec = { group: 0, level: 0 };
/**
 * Gathers checks to be run against structures and groups them by check group and then by level.
 */
function tasks(unit, checksResolver) {
    const mmVersion = unit.model.metaModelVersion;
    const checkTasksPerLevelPerGroup = [];
    function lazilyCreatingGet(buckets, index) {
        let bucket = buckets[index];
        if (!bucket) {
            bucket = [];
            buckets[index] = bucket;
        }
        return bucket;
    }
    unit.traverse(structure => {
        const checks = checksResolver(structure.structureTypeName);
        if (checks) {
            checks.forEach(check => {
                const checkBody = versioning_1.lookupByVersion(check.versionCheckBodies, mmVersion);
                const runSpec = checkBody.runSpec || alwaysRunSpec;
                const checkTasksPerLevel = lazilyCreatingGet(checkTasksPerLevelPerGroup, runSpec.group);
                const checkTasks = lazilyCreatingGet(checkTasksPerLevel, runSpec.level);
                checkTasks.push({
                    structure: structure,
                    checkBody: checkBody,
                    checkName: check.name
                });
            });
        }
    });
    return checkTasksPerLevelPerGroup;
}
//# sourceMappingURL=checks-runner.js.map