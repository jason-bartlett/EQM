"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const instances_1 = require("../../sdk/internal/instances");
const structures_1 = require("../internal/structures");
const standard_library_iterators_1 = require("./standard-library-iterators");
const standard_library_methods_1 = require("./standard-library-methods");
const versioning_1 = require("./versioning");
const context_1 = require("./context");
/* tslint:disable: no-shadowed-variable */
function evaluateExpression(expr, structure, queryResolver, context = null) {
    // share model across all helper functions (fall-backs are purely for testing...):
    const model = structure ? structure.model : undefined;
    const modelClasses = structure ? model._allModelClasses() : {};
    return _eval(expr, structure, context || context_1.Context.createWithThis(structure));
    function _eval(evaluatable, source, context) {
        const polyMap = {
            // for every non-abstract sub type of Evaluatable, provide an interpretation -- please sort by type name:
            "MxBinaryExpression": (expr) => evalBinary(expr, source, context),
            "MxBooleanLiteralExpression": (expr) => expr.value,
            "MxColorLiteralExpression": (expr) => {
                const colorExpr = expr;
                return { red: colorExpr.red, green: colorExpr.green, blue: colorExpr.blue };
            },
            "MxDoubleLiteralExpression": (expr) => expr.value,
            "MxFeatureCallWrapper": (expr) => _eval(expr.featureCall, source, context),
            "MxFollowExcluding": (expr) => evalFollowExcluding(expr, source, context),
            "MxFollowIncluding": (expr) => evalFollowIncluding(expr, source, context),
            "MxIntegerLiteralExpression": (expr) => expr.value,
            "MxIteratorCall": (expr) => evalIteratorCall(expr, source, context),
            "MxListLiteralExpression": (expr) => {
                const listLiteralExpr = expr;
                const evalItems = listLiteralExpr.items.map(item => _eval(item, source, context));
                return evalItems.some(isNothing) ? undefined : evalItems;
                // simple failure semantics: propagate undefined
            },
            "MxMethodCall": (expr) => evalMethodCall(expr, source, context),
            "MxPrefixExpression": (expr) => {
                const exprEval = _eval(expr.expression, source, context);
                return isNothing(exprEval) ? exprEval : (!exprEval); // simple failure semantics: propagate undefined
            },
            "MxPreviousExpression": (expr) => context.getIterationState(expr.variable.referredVariable).previous().value(),
            "MxPropertyCall": (expr) => isNothing(source) ? undefined : source[expr.referredProperty],
            "MxQualifiedEnumLiteralExpression": (expr) => evalQualifiedEnumLiteral(expr),
            "MxSizeLiteralExpression": (expr) => {
                const sizeLiteralExpr = expr;
                return { height: sizeLiteralExpr.height, width: sizeLiteralExpr.width };
            },
            "MxStringLiteralExpression": (expr) => expr.value,
            "MxStructureLiteralExpression": (expr) => evalStructureLiteral(expr, source, context),
            "MxSwitch": (expr) => evalSwitch(expr, source, context),
            "MxThisExpression": (expr) => context.getThis(),
            "MxTypeStructureLiteralExpression": (expr) => {
                const typeStructureLiteralExpr = expr;
                return new standard_library_methods_1.StructureTypeLiteral(instances_1.instancehelpers.lookupClass(typeStructureLiteralExpr.referredStructure, modelClasses));
            },
            "MxUndefinedExpression": (expr) => undefined,
            "MxVariableRefExpression": (expr) => context.getValue(expr.referredVariable)
        };
        const evalFn = polyMap[evaluatable.$Type];
        if (!evalFn) {
            throw new Error(`unhandled expression type: ${evaluatable.$Type}`);
        }
        const baseEval = evalFn(evaluatable);
        // for some debugging convenience: call logBaseEval(evaluatable, source, baseEval) using expressions-debug-util
        return evalApplicable(evaluatable, baseEval, context);
    }
    function evalApplicable(expr, baseEval, context) {
        return !expr.appliedFeature // no check for nothingness: e.g. '.isUndefined()' can turn nothing into something
            ? baseEval // simple failure semantics: propagate undefined
            : _eval(expr.appliedFeature, baseEval, context);
    }
    function evalBinary(expr, source, context) {
        if (expr.operator === "NONE") {
            throw new Error("sentinel value of MxOperator not allowed in runtime");
        }
        const evalLeft = _eval(expr.left, source, context);
        const evalRight = _eval(expr.right, source, context); // (no shortcutting)
        if (isNothing(evalLeft) || isNothing(evalRight)) {
            switch (expr.operator) {
                case "UNEQUALS": return true;
                case "AND": return undefined;
                case "OR":
                    if (isNothing(evalLeft) && isNothing(evalRight)) {
                        return false;
                    }
                    // take the [not-un]defined one:
                    return isNothing(evalLeft) ? evalRight : evalLeft;
                default: return false;
            }
        }
        switch (expr.operator) {
            case "AND": return evalLeft && evalRight;
            case "EQUALS": return evalLeft === evalRight;
            case "GREATER": return evalLeft > evalRight; // (no type coercion)
            case "GREATER_OR_EQUALS": return (evalLeft > evalRight) || (evalLeft === evalRight); // (some type coercion)
            case "LESS": return evalLeft < evalRight; // (no type coercion)
            case "LESS_OR_EQUALS": return (evalLeft < evalRight) || (evalLeft === evalRight); // (some type coercion)
            case "OR": return evalLeft || evalRight;
            case "UNEQUALS": return evalLeft !== evalRight;
            default: return undefined;
        }
    }
    function evalFollowExcluding(expr, source, context) {
        const evalIncluding = evalFollowIncluding(expr, source, context);
        return isNothing(evalIncluding) || !Array.isArray(evalIncluding) ? evalIncluding : evalIncluding.slice(1);
    }
    // Note: takes expr of type MxAbstractFollow!
    function evalFollowIncluding(expr, source, context) {
        if (isNothing(source)) {
            return undefined;
        }
        const visited = [];
        let currentElement = source;
        while (!isNothing(currentElement)) { // (always true for 1st iteration)
            if (visited.indexOf(currentElement) > -1) { // (check before adding)
                visited.push(currentElement); // cycle!
                break;
            }
            visited.push(currentElement);
            currentElement = _eval(expr.path, currentElement, context.withValue(expr.variable.name, currentElement));
        }
        return visited;
    }
    function evalIteratorCall(expr, source, context) {
        const iterator = standard_library_iterators_1.standardIterators[expr.type];
        if (!iterator) {
            throw new Error(`Iterator not implemented: '${expr.type}'`);
        }
        return iterator(source, (value, index, array) => _eval(expr.body, undefined /* could be "source" but nothing seems to be more correct */, context.withIterationState(expr.variable.name, new standard_library_iterators_1.IterationState(index, array))));
    }
    function evalMethodCall(expr, source, context) {
        const method = standard_library_methods_1.standardLibraryMethods[expr.referredMethod];
        if (method) {
            const argValues = (expr.arguments || []).map(argExpr => _eval(argExpr, source, context)).slice();
            // for some debugging convenience:
            // 		call logMethodCall(expr, source, argValues, result) using expressions-debug-util,
            // 		with result = method(source, argValues)
            return method(source, argValues);
        }
        if (isNothing(source)) { // check nothingness only for query since nothing can be valid/useful input for methods
            return undefined;
        }
        if (!(source instanceof structures_1.Structure)) {
            throw new Error(`Cannot call query '${expr.referredMethod}' on non-Structure`);
        }
        const query = queryResolver(expr.referredMethod, source.structureTypeName);
        if (query) {
            const queryBody = versioning_1.lookupByVersion(query.queryVersions, model.metaModelVersion);
            let queryContext = context.withThis(source);
            if (query.parameters) {
                const argValues = (expr.arguments || []).map(argExpr => _eval(argExpr, source, context)).slice();
                query.parameters.forEach((item, index) => {
                    queryContext = queryContext.withValue(query.parameters[index].name, argValues[index]);
                });
            }
            if (queryBody.variables) {
                for (const variable of queryBody.variables) {
                    queryContext = queryContext.withValue(variable.name, _eval(variable.value, source, queryContext));
                }
            }
            return _eval(queryBody.value, source, queryContext);
        }
        throw new Error(`Method not implemented by either standard lib or as query `
            + `on instance of ${source.structureTypeName}: ${expr.referredMethod}`);
    }
    function evalQualifiedEnumLiteral(expr) {
        const enumClazz = instances_1.instancehelpers.lookupClass(expr.enumeration, modelClasses);
        const literal = enumClazz[expr.literal];
        if (!literal) {
            return undefined;
        }
        return literal;
    }
    function evalStructureLiteral(expr, source, context) {
        const assignments = {};
        for (const assignment of expr.assignments) {
            const evalAssignment = _eval(assignment.value, source, context);
            if (isNothing(evalAssignment)) {
                return undefined;
            }
            assignments[assignment.property] = evalAssignment;
        }
        const clazz = instances_1.instancehelpers.lookupClass(expr.structure, modelClasses);
        const newStructure = clazz.create(model);
        if (!newStructure) {
            return undefined;
        }
        for (const propertyName in assignments) {
            newStructure["__" + propertyName].set(assignments[propertyName]);
        }
        return newStructure;
    }
    function evalSwitch(expr, source, context) {
        const switchContext = context.withValue(expr.variable.name, source);
        for (const switchCase of expr.cases) {
            if (evalSwitchCase(switchCase, source, switchContext)) {
                return _eval(switchCase.value, undefined, switchContext);
            }
        }
        return undefined;
    }
    function evalSwitchCase(switchCase, source, context) {
        const typeMatches = (() => {
            if (!switchCase.expectedType) {
                return true;
            }
            const typeLiteral = _eval(switchCase.expectedType, undefined, context);
            return isNothing(typeLiteral) ? false : source instanceof typeLiteral.clazz;
        })();
        return typeMatches && /* condition matches: */ (!switchCase.condition || !!_eval(switchCase.condition, undefined, context));
    }
}
exports.evaluateExpression = evaluateExpression;
/**
 * Checks whether the argument is "nothing", i.e. either undefined or null.
 */
function isNothing(arg) {
    return (arg === undefined || arg === null);
}
exports.isNothing = isNothing;
//# sourceMappingURL=expressions-evaluator.js.map