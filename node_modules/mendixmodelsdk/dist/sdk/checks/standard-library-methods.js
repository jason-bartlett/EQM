"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const mobx_1 = require("mobx");
const utils_1 = require("../utils");
const expressions_evaluator_1 = require("./expressions-evaluator");
const structures_1 = require("../internal/structures");
const elements_1 = require("../internal/elements");
const units_1 = require("../internal/units");
const name_util_1 = require("./name-util");
exports.standardLibraryMethods = {
    // (in alphabetic order, for easy lookup:)
    asType: asType,
    concat: concat,
    container: container,
    containerAs: containerAs,
    contains: contains,
    firstContainerOfType: firstContainerOfType,
    firstContainerOfTypes: firstContainerOfTypes,
    flatten: flatten,
    get: get,
    hasDuplicates: hasDuplicates,
    isDefined: isDefined,
    isEmpty: isEmpty,
    isEmptyOrUndefined: isEmptyOrUndefined,
    isOfType: isOfType,
    isUndefined: isUndefined,
    last: last,
    length: length,
    modelUnit: modelUnit,
    notEmpty: notEmpty,
    parts: parts,
    partsOfType: partsOfType,
    qualifiedName: qualifiedName,
    toLowerCase: toLowerCase,
    typeFilter: typeFilter,
    startsWith: startsWith,
    validateName: validateName
};
function isNotList(items) {
    return expressions_evaluator_1.isNothing(items) || !(lodash_1.isArray(items) || mobx_1.isObservableArray(items));
}
function firstArg(args) {
    return isNotList(args) ? undefined : args[0];
}
function asType(source, args) {
    const typeLiteral = firstArg(args);
    return (expressions_evaluator_1.isNothing(source)
        || !(source instanceof structures_1.Structure)
        || expressions_evaluator_1.isNothing(typeLiteral)
        || !(typeLiteral instanceof StructureTypeLiteral)
        || !(source instanceof typeLiteral.clazz))
        ? undefined
        : source;
}
function concat(items, args) {
    const toConcat = firstArg(args);
    if (isNotList(toConcat) || isNotList(items)) {
        return undefined;
    }
    return items.concat(toConcat);
}
function container(source) {
    return expressions_evaluator_1.isNothing(source)
        ? undefined
        : source.container;
}
function containerAs(source, args) {
    const typeLiteral = firstArg(args);
    if (expressions_evaluator_1.isNothing(source) || !(source instanceof structures_1.Structure) || expressions_evaluator_1.isNothing(typeLiteral)) {
        return undefined;
    }
    const _container = container(source);
    if (expressions_evaluator_1.isNothing(_container)) {
        return undefined;
    }
    return asType(_container, [typeLiteral]);
}
function contains(items, args) {
    const element = firstArg(args);
    if (isNotList(items) || expressions_evaluator_1.isNothing(element)) {
        return undefined;
    }
    return items.indexOf(element) > -1;
}
function firstContainerOfType(source, args) {
    const typeLiteral = firstArg(args);
    if (expressions_evaluator_1.isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
        return undefined;
    }
    return firstContainerOfTypes(source, [typeLiteral]);
}
function firstContainerOfTypes(source, args) {
    const typeLiterals = isNotList(args) ? [] : args.filter(typeLiteral => typeLiteral instanceof StructureTypeLiteral);
    if (expressions_evaluator_1.isNothing(source) || !(source instanceof structures_1.Structure) || typeLiterals.length === 0) {
        return undefined;
    }
    let currentStructure = source.container;
    while (!expressions_evaluator_1.isNothing(currentStructure) && !(typeLiterals.some(typeLiteral => currentStructure instanceof typeLiteral.clazz))) {
        currentStructure = currentStructure.container;
    }
    return currentStructure || undefined;
}
function flatten(items) {
    if (isNotList(items)) {
        return undefined;
    }
    return utils_1.utils.flatten(items);
}
function get(items, args) {
    if (isNotList(items) || isNotList(args) || !lodash_1.isNumber(args[0])) {
        return undefined;
    }
    const index = args[0];
    return (index < 1 || items.length < index) ? undefined : items[index - 1];
}
function hasDuplicates(items) {
    if (isNotList(items)) {
        return undefined;
    }
    const list = items;
    return lodash_1.uniq(list).length < list.length;
}
function isDefined(source) {
    return !expressions_evaluator_1.isNothing(source);
}
function isEmpty(items) {
    return (isNotList(items)) ? undefined : (items.length === 0);
}
function isEmptyOrUndefined(items) {
    return expressions_evaluator_1.isNothing(items) || isEmpty(items);
}
function isOfType(source, args) {
    const typeLiteral = firstArg(args);
    return (expressions_evaluator_1.isNothing(source)
        || !(source instanceof structures_1.Structure)
        || expressions_evaluator_1.isNothing(typeLiteral)
        || !(typeLiteral instanceof StructureTypeLiteral))
        ? undefined
        : (source instanceof typeLiteral.clazz);
}
function isUndefined(source) {
    return expressions_evaluator_1.isNothing(source);
}
function last(items) {
    return (isNotList(items))
        ? undefined
        : lodash_1.last(items);
}
function length(items) {
    return (isNotList(items))
        ? undefined
        : items.length;
}
function modelUnit(source) {
    if (expressions_evaluator_1.isNothing(source) || !(source instanceof structures_1.Structure)) {
        return undefined;
    }
    return source instanceof units_1.AbstractUnit ? source : source.unit;
}
function notEmpty(items) {
    return (isNotList(items)) ? undefined : (items.length > 0);
}
function parts(source) {
    if (expressions_evaluator_1.isNothing(source)) {
        return [];
    }
    if (!(source instanceof structures_1.Structure)) {
        return undefined;
    }
    const something = source;
    const structures = [];
    something.traverse(structure => {
        if (structure !== something) {
            structures.push(structure);
        }
    });
    return structures;
}
function partsOfType(source, args) {
    if (expressions_evaluator_1.isNothing(source)) {
        return [];
    }
    const something = source;
    const typeLiteral = firstArg(args);
    if (!(something instanceof structures_1.Structure) || expressions_evaluator_1.isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
        return undefined;
    }
    const structures = [];
    something.traverse(structure => {
        if (structure !== something && structure instanceof typeLiteral.clazz) {
            structures.push(structure);
        }
    });
    return structures;
}
function qualifiedName(source) {
    return expressions_evaluator_1.isNothing(source) || !(source instanceof elements_1.AbstractElement)
        ? undefined
        : source._getQualifiedName();
}
function toLowerCase(source) {
    if (expressions_evaluator_1.isNothing(source)) {
        return undefined;
    }
    return source.toLowerCase();
}
function typeFilter(items, args) {
    const typeLiteral = firstArg(args);
    if (expressions_evaluator_1.isNothing(items) || expressions_evaluator_1.isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
        return undefined;
    }
    return items.filter(item => item instanceof typeLiteral.clazz);
}
function startsWith(source, args) {
    if (expressions_evaluator_1.isNothing(source) || isNotList(args) || !lodash_1.isString(args[0])) {
        return undefined;
    }
    return source.indexOf(args[0]) === 0;
}
function validateName(source) {
    return name_util_1.validateSyntax(source);
}
class StructureTypeLiteral {
    constructor(clazz /* TODO  sharpen type */) {
        this.clazz = clazz;
    }
}
exports.StructureTypeLiteral = StructureTypeLiteral;
//# sourceMappingURL=standard-library-methods.js.map