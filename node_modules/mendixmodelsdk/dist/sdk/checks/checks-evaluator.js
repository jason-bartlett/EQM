"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const expressions_evaluator_1 = require("./expressions-evaluator");
const versioning_1 = require("./versioning");
const context_1 = require("./context");
// only used for testing:
function evaluateCheck(check, structure, queryResolver) {
    const checkBody = versioning_1.lookupByVersion(check.versionCheckBodies, structure.model.metaModelVersion);
    return evaluateCheckBody(check.name, checkBody, structure, queryResolver);
}
exports.evaluateCheck = evaluateCheck;
function evaluateCheckBody(checkName, checkBody, structure, queryResolver) {
    function evaluateExpressionProtected(expr, context, description, fallBackOnError, warnOnNothing = false) {
        try {
            const exprEval = expressions_evaluator_1.evaluateExpression(expr, structure, queryResolver, context);
            if (warnOnNothing && expressions_evaluator_1.isNothing(exprEval)) {
                console.warn(`${description} on instance of '${structure.structureTypeName}' -> nothing`);
            }
            return exprEval;
        }
        catch (e) {
            console.error(`could not evaluate ${description} on instance of '${structure.structureTypeName}' due to: ${e}`);
            return fallBackOnError();
        }
    }
    let context = context_1.Context.createWithThis(structure);
    if (checkBody.variables) {
        checkBody.variables.forEach(variable => {
            context = context.withValue(variable.name, evaluateExpressionProtected(variable.value, null, `value expression for variable '${variable.name}'`, () => undefined));
        });
    }
    /*
     * Protect evaluation of check condition against throws and provide some debugging info in that case.
     * It is not regular that the check condition evaluates to nothing, so that's reported as well.
     */
    const conditionEval = evaluateExpressionProtected(checkBody.checkCondition.rule, context, `check condition of check '${checkName}'`, () => (checkBody.checkCondition.$Type === "MxCheckConditionForList") ? [] : undefined, true // warn on nothing
    );
    const isListy = (() => {
        switch (checkBody.checkCondition.$Type) {
            case "MxCheckConditionForBoolean": return false;
            case "MxCheckConditionForList": return true;
            default:
                throw new Error(`unhandled type for MxCheck.checkCondition: ${checkBody.checkCondition.$Type}`);
        }
    })();
    const faultyStructures = isListy
        ? conditionEval
        : (!!conditionEval ? [structure] : []); // undefined -> false
    return faultyStructures.map(forStructure => {
        return {
            structure: forStructure,
            message: calculateMessage(structure, // structure check was run on, which is 'this' in message arguments
            checkBody.message, queryResolver, isListy ? context.withValue(checkBody.checkCondition.errorVar.name, forStructure) : context),
            severity: checkBody.severity,
            incorrectProperty: checkBody.incorrectProperty,
            checkName: checkName
        };
    });
}
exports.evaluateCheckBody = evaluateCheckBody;
/* (exported for testing) */
function calculateMessage(structure, message, queryResolver, context = null) {
    const evaluatedArgs = message.arguments ? message.arguments.map(arg => expressions_evaluator_1.evaluateExpression(arg, structure, queryResolver, context)) : [];
    return message.text.replace(/\{(\d+?)\}/g, (match, key) => evaluatedArgs[key]);
}
exports.calculateMessage = calculateMessage;
//# sourceMappingURL=checks-evaluator.js.map