"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const delta_sender_1 = require("./delta-sender");
const delta_reverser_1 = require("./delta-reverser");
const delta_processor_1 = require("./delta-processor");
const delta_utils_1 = require("./delta-utils");
const transaction_checks_1 = require("../transaction-checks");
// tslint:disable-next-line
const EventEmitter = require("wolfy87-eventemitter");
class DeltaManager {
    constructor(model) {
        this.model = model;
        /** @internal */
        this.queue = [];
        this.transactionPending = false;
        this.eventEmitter = new EventEmitter();
        this.deltaSender = new delta_sender_1.DeltaSender(model, () => this.callCloseCallback(), error => this.callErrorCallback(error));
        this.deltaReverser = new delta_reverser_1.DeltaReverser(model);
        this.deltaProcessor = new delta_processor_1.DeltaProcessor(model);
        this.transactionChecks = new transaction_checks_1.TransactionChecks(model);
    }
    get isClosing() {
        return this.deltaSender.isClosing;
    }
    /**
     * Closes the "connection" with the Model API Server in the sense that
     * pending delta requests are processed, and that afterwards the given
     * `callback` will be called.
     * This function can only be called once.
     */
    closeConnection(closeCallback, errorCallback) {
        this.closeCallback = closeCallback;
        this.errorCallback = errorCallback;
        // If closeConnection is called in the same tick that deltas have been added, send the deltas.
        if (this.transactionPending) {
            this.commitTransaction();
        }
        this.deltaSender.closeConnection();
    }
    /**
     * Pushes the given `delta` on the queue for scheduling/processing.
     */
    push(delta) {
        this.queue.push(delta);
        this.eventEmitter.emitEvent(DeltaManager.NEW_DELTA, [delta]);
        this.transactionChecks.onNewDelta(delta);
        this.scheduleCommitTransaction();
    }
    processDeltas(deltas) {
        this.deltaProcessor.processDeltas(delta_utils_1.removeUselessDeltas(deltas));
        this.deltaSender.scheduleDeltas(deltas);
    }
    reverseDelta(delta) {
        return this.deltaReverser.reverse(delta);
    }
    onNewDelta(callback) {
        this.eventEmitter.on(DeltaManager.NEW_DELTA, callback);
    }
    onTransactionWillCommit(callback) {
        this.eventEmitter.on(DeltaManager.TRANSACTION_WILL_COMMIT, callback);
    }
    onTransactionDidCommit(callback) {
        this.eventEmitter.on(DeltaManager.TRANSACTION_DID_COMMIT, callback);
    }
    // TODO: remove it. Only used in tests.
    set checkDetachedStructures(value) {
        this.transactionChecks.checkDetachedStructures = value;
    }
    callCloseCallback() {
        if (this.closeCallback) {
            this.closeCallback();
        }
    }
    callErrorCallback(error) {
        if (this.errorCallback) {
            this.errorCallback(error);
        }
        else {
            this.model._errorHandler(error);
        }
    }
    scheduleCommitTransaction() {
        if (this.transactionPending) {
            return;
        }
        this.transactionPending = true;
        setTimeout(() => this.commitTransaction(), 0);
    }
    commitTransaction() {
        if (!this.transactionPending) {
            return;
        }
        this.eventEmitter.emitEvent(DeltaManager.TRANSACTION_WILL_COMMIT, this.queue);
        try {
            this.transactionChecks.check(this.queue);
        }
        catch (error) {
            this.callErrorCallback(error);
            return;
        }
        this.deltaSender.scheduleDeltas(this.queue.slice());
        this.queue.splice(0, this.queue.length);
        this.eventEmitter.emitEvent(DeltaManager.TRANSACTION_DID_COMMIT);
        this.transactionPending = false;
    }
}
DeltaManager.NEW_DELTA = "NewDelta";
DeltaManager.TRANSACTION_WILL_COMMIT = "TransactionWillCommit";
DeltaManager.TRANSACTION_DID_COMMIT = "TransactionDidCommit";
exports.DeltaManager = DeltaManager;
//# sourceMappingURL=delta-manager.js.map