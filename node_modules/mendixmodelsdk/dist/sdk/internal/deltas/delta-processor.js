"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const units_1 = require("../units");
const elements_1 = require("../elements");
const properties_1 = require("../properties");
const instances_1 = require("../instances");
const deltaUtils = require("./delta-utils");
class DeltaProcessor {
    constructor(model) {
        this.model = model;
    }
    processDeltas(deltas) {
        for (const delta of deltas) {
            const unit = deltaUtils.getUnitForDelta(this.model, delta);
            switch (delta.deltaType) {
                case "UPDATE_PROPERTY_VALUE":
                    this.processUpdatePropertyValueDelta(unit, delta);
                    break;
                case "CREATE_ELEMENT_TREE":
                    this.processCreateElementTreeDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "DELETE_ELEMENT":
                    this.processDeleteElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "ATTACH_ELEMENT":
                    this.processAttachElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                case "DETACH_ELEMENT":
                    this.processDetachElementDelta(deltaUtils.asModelUnit(unit), delta);
                    break;
                default:
                    throw new Error(`Delta type ${delta.deltaType} is not supported.`);
            }
        }
    }
    processUpdatePropertyValueDelta(unit, delta) {
        const structure = unit instanceof units_1.StructuralUnit ? unit :
            deltaUtils.findElement(this.model, deltaUtils.asModelUnit(unit), delta.elementId);
        const property = deltaUtils.findProperty(structure, delta.propertyName);
        if (property instanceof properties_1.PartProperty || property instanceof properties_1.PartListProperty) {
            throw new Error("Cannot apply UPDATE_PROPERTY_VALUE delta to part (list) properties");
        }
        if (property instanceof properties_1.StructuralChildProperty || property instanceof properties_1.StructuralChildListProperty) {
            throw new Error("Cannot apply UPDATE_PROPERTY_VALUE delta to structural child (list) properties");
        }
        deltaUtils.checkMutator(delta.mutator, property);
        deltaUtils.updateStructure(structure, () => {
            this.processMutator(structure, property, delta.mutator);
        });
    }
    processMutator(structure, property, mutator) {
        switch (mutator.mutatorType) {
            case "CHANGE":
                if (deltaUtils.isListProperty(property)) {
                    const rawList = deltaUtils.rawList(property);
                    rawList[mutator.updateIndex] = mutator.value;
                    property.updateWithRawValue(rawList);
                }
                else {
                    property.updateWithRawValue(mutator.value);
                    if (property instanceof properties_1.ByIdReferenceProperty) {
                        property.resolveReference();
                    }
                    if (property instanceof properties_1.PrimitiveProperty && property.name === "name") {
                        // Needs to be done to update client cache and client renaming, will not run automatically when _isUpdating is true.
                        structure._processNameChange();
                    }
                }
                break;
            case "ADD":
                const index = util_1.isNumber(mutator.insertionIndex) ? mutator.insertionIndex : property.get().length;
                const rawList = deltaUtils.rawList(property);
                rawList.splice(index, 0, mutator.value);
                property.updateWithRawValue(rawList);
                break;
            case "REMOVE":
                property.get().splice(mutator.removalIndex, 1);
                break;
            default:
                throw new Error(`Invalid mutatorType: ${JSON.stringify(mutator)}`);
        }
    }
    processCreateElementTreeDelta(unit, delta) {
        if (!delta.elementTree) {
            throw new Error("Missing elementTree");
        }
        const parentElement = deltaUtils.findElement(this.model, unit, delta.parentId);
        const parentProperty = deltaUtils.findProperty(parentElement, delta.parentPropertyName);
        let newElement;
        if (parentProperty instanceof properties_1.PartProperty) {
            parentProperty.updateWithRawValue(delta.elementTree);
            newElement = parentProperty.get();
        }
        else if (parentProperty instanceof properties_1.PartListProperty) {
            newElement = instances_1.instancehelpers.modelElementJsonToInstance(this.model, unit, parentElement, delta.elementTree, false);
            deltaUtils.updateStructure(parentElement, () => {
                if (delta.additionIndex !== undefined) {
                    deltaUtils.checkInsertionIndex(delta.additionIndex, parentProperty);
                    parentProperty.get().splice(delta.additionIndex, 0, newElement);
                }
                else {
                    parentProperty.get().push(newElement);
                }
            });
        }
        else {
            throw new Error("CREATE_ELEMENT_TREE parent property should be a PartProperty or PartListProperty");
        }
        // This is needed because updateWithRawValue does not automatically add the new element to the QN cache.
        unit.model._qualifiedNameCache.addStructureToCache(newElement);
        // This is needed because creating an element from JSON does not automatically resolve by-id references.
        unit.resolveByIdReferences();
    }
    processDeleteElementDelta(unit, delta) {
        const element = deltaUtils.findElement(this.model, unit, delta.elementId);
        if (element._isDetached) {
            throw new Error("Cannot delete a detached element");
        }
        deltaUtils.updateStructure(element, () => {
            if (element.container) {
                const handle = element.container._childHandle(element);
                const property = handle.containingProperty;
                if (property instanceof properties_1.PartListProperty) {
                    property.detachChild(element);
                }
                else if (property instanceof properties_1.PartProperty) {
                    property.detachValue();
                }
            }
            element._deleteInternal();
        });
    }
    processAttachElementDelta(unit, delta) {
        const element = this.model.detachedStructures.filter(e => e.id === delta.elementId)[0];
        if (!element) {
            throw new Error(`Cannot find detached element with ID '${delta.elementId}'`);
        }
        const parentElement = deltaUtils.findElement(this.model, unit, delta.newParentId);
        const parentProperty = deltaUtils.findProperty(parentElement, delta.newParentPropertyName);
        if (parentProperty instanceof properties_1.PartProperty) {
            if (parentProperty.get()) {
                throw new Error("Cannot attach element to PartProperty that already has a value");
            }
            deltaUtils.updateStructure(element, () => parentProperty.set(element));
        }
        else if (parentProperty instanceof properties_1.PartListProperty) {
            deltaUtils.updateStructure(element, () => {
                if (delta.newIndex !== undefined) {
                    deltaUtils.checkInsertionIndex(delta.newIndex, parentProperty);
                    parentProperty.get().splice(delta.newIndex, 0, element);
                }
                else {
                    parentProperty.get().push(element);
                }
            });
        }
        else {
            throw new Error("ATTACH_ELEMENT new parent property should be a PartProperty or PartListProperty");
        }
    }
    processDetachElementDelta(unit, delta) {
        const element = deltaUtils.findElement(this.model, unit, delta.elementId);
        if (!(element instanceof elements_1.Element)) {
            throw new Error("Cannot detach a model unit");
        }
        if (!element._isAttached) {
            throw new Error("Cannot detach an element that is already detached");
        }
        deltaUtils.updateStructure(element, () => element.detach());
    }
}
exports.DeltaProcessor = DeltaProcessor;
//# sourceMappingURL=delta-processor.js.map