"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_1 = require("mobx");
const deltas_1 = require("./deltas");
const instances_1 = require("./instances");
const version_checks_1 = require("./version-checks");
const utils_1 = require("../utils");
const properties_1 = require("./properties");
const qualified_name_cache_1 = require("./qualified-name-cache");
// tslint:disable-next-line
const EventEmitter = require("wolfy87-eventemitter");
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
class AbstractModel {
    constructor(_client, _errorHandler, _connectionConfig) {
        /** @internal */
        this.detachedStructures = [];
        /**
         * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
         * @internal
         */
        this._units = {};
        /**
         * Map qualifiedName -> AbstractElement[]; the same qualified name could potentially refer to different kind of objects;
         * e.g. MyFirstModule.SecondThing could both be an entity or a microflow.
         *
         * A structure has a qualified name precisely if it's public, publicly contained through namespaces and
         * has a public, 1-string-typed `name` property.
         * In other words: every structure having a qualified name is already present in the interface of the containing unit.
         * So, as soon as the `_processLoadedUnitInterfaces` has been called the cache is complete (no lazy loading).
         * (It still needs to be continuously updated obviously.)
         *
         * @internal
         */
        this._qualifiedNameCache = new qualified_name_cache_1.QualifiedNameCache(this);
        /**
         * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
         * Please extend the type whenever applicable, for convenience of the programmer.
         *
         * @internal
         */
        this._unitsByType = {};
        /** @internal */
        this._areUnitInterfacesLoaded = false;
        /** @internal */
        this.eventEmitter = new EventEmitter();
        this._client = _client;
        this._errorHandler = _errorHandler;
        this._connectionConfig = _connectionConfig;
    }
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
     * or call the errorHandler if this fails.
     */
    static read(client, workingCopyId, connectionConfig, instance, callback, errorCallback) {
        AbstractModel.readImpl(instance, workingCopyId, callback);
    }
    static readImpl(instance, workingCopyId, callback) {
        // TODO  use promises to avoid callback admin mess
        let hasError = false;
        let processMetaDataCallback;
        let processUnitInterfacesCallback;
        const guardedCallback = () => {
            if (!hasError && processMetaDataCallback && processUnitInterfacesCallback) {
                /*
                 * order is important: metadata (e.g. version) must be set first,
                 * then unit-interfaces (which uses version), then the user can do his/her thing.
                 */
                processMetaDataCallback();
                processUnitInterfacesCallback();
                callback(instance);
            }
        };
        const guardedErrorCallback = (err) => {
            if (!hasError) {
                hasError = true;
                instance._errorHandler(err);
            }
            // Loading is parallel, if multiple errors occur, we are only interested in the first one..
        };
        instance._loadMetaData(workingCopyId, (processCallback) => {
            processMetaDataCallback = processCallback;
            return void guardedCallback();
        }, guardedErrorCallback);
        instance._loadUnitInterfaces(workingCopyId, (processCallback) => {
            processUnitInterfacesCallback = processCallback;
            return void guardedCallback();
        }, guardedErrorCallback);
    }
    closeConnection(callback, errorCallback) {
        setTimeout(() => this.deltaManager.closeConnection(callback, errorCallback), 1);
    }
    get id() {
        return this.workingCopy.id;
    }
    /** @internal */
    get _unitTypes() {
        return Object.keys(this._unitsByType);
    }
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     *
     * @internal
     */
    _unitInterfacesByType(structureTypeName) {
        if (!(structureTypeName in this._unitsByType)) {
            mobx_1.extendObservable(this._unitsByType, { [structureTypeName]: mobx_1.observable.array([], { deep: false }) });
        }
        return this._unitsByType[structureTypeName];
    }
    /**
     * Returns a defensive collection of all units in this model.
     */
    allUnits() {
        const result = [];
        for (const key in this._unitsByType) {
            const objects = this._unitsByType[key];
            result.push(...objects.slice());
        }
        return result;
    }
    /** @internal */
    _sendDelta(delta) {
        this.deltaManager.push(delta);
    }
    /**
     * Registers the given `unit` in the cache(s).
     *
     * @internal
     */
    _addUnit(unit) {
        if (!unit.structureTypeName) {
            throw new Error("Illegal state: unit has no type name specified");
        }
        if (!this._units[unit.id]) {
            this._units[unit.id] = unit;
            this._unitInterfacesByType(unit.structureTypeName).push(unit);
        }
    }
    /**
     * Unregisters the given `unit` from the cache(s).
     *
     * @internal
     */
    _removeUnit(unit) {
        delete this._units[unit.id];
        const idx = this._unitsByType[unit.structureTypeName].indexOf(unit); // yay for pointer equality
        if (idx > -1) {
            this._unitsByType[unit.structureTypeName].splice(idx, 1);
        }
    }
    handleError(message, errorCallback) {
        if (errorCallback) {
            errorCallback(new Error(message));
        }
        else {
            this._errorHandler(new Error(message));
        }
    }
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    loadUnitById(id, forceRefresh, callback, errorCallback) {
        if (id === null) {
            this.handleError("Unit ID is null", errorCallback);
            return;
        }
        const unit = this._units[id];
        if (!unit) {
            this.handleError("Unknown unit ID: " + id, errorCallback);
        }
        else if (forceRefresh) {
            // make sure we can load the unit again:
            unit._markNotLoaded();
            this._loadUnit(unit, callback, errorCallback);
        }
        else if (unit._isLoading) {
            // This cast is ok because when we know that the item being loaded has type T
            unit._registerAfterLoadCallback(callback);
        }
        else if (unit.isLoaded) {
            setTimeout(() => {
                callback(unit);
            }, 1);
        }
        else {
            this._loadUnit(unit, callback, errorCallback);
        }
    }
    /** @internal */
    _loadUnit(unit, callback, errorCallback) {
        unit._registerAfterLoadCallback(loadedUnit => {
            this.eventEmitter.emitEvent(AbstractModel.UNIT_LOADED, [loadedUnit.id]);
            callback(loadedUnit);
        });
        unit._markLoading();
        this._client.loadUnitById(this.workingCopy.id, unit.id, (data) => {
            mobx_1.runInAction(() => {
                unit._updateWithJson(data);
                this._resolveContainer(unit, data.containerId);
                unit.resolveByIdReferences();
            });
            unit._markLoaded();
        }, errorCallback || this._errorHandler);
    }
    filterUnitsByCustomWidgetId(workingCopyId, widgetId, callback, errorCallback) {
        this._client.filterUnitsByCustomWidgetId(workingCopyId, widgetId, callback, errorCallback);
    }
    /** @internal */
    _loadMetaData(workingCopyId, callback, errorCallback) {
        this._client.loadWorkingCopyMetaData(workingCopyId, (data) => {
            callback(this._processLoadedMetaData.bind(this, data));
        }, errorCallback);
    }
    /** @internal */
    _processLoadedMetaData(data) {
        this.workingCopy = data;
        this.metaModelVersion = version_checks_1.parseAsNormalizedVersion(data.metaData.metaModelVersion);
        this.mxVersionForModel = version_checks_1.parseAsNormalizedVersion(data.mprMetaData._ProductVersion);
        this.deltaManager = new deltas_1.DeltaManager(this);
    }
    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     *
     * @internal
     */
    _loadUnitInterfaces(workingCopyId, callback, errorCallback) {
        if (this._areUnitInterfacesLoaded) {
            throw new Error("Illegal state: unit interfaces already loaded");
        }
        this._client.loadUnitInterfaces(workingCopyId, (data) => {
            return void callback(this._processLoadedUnitInterfaces.bind(this, data));
        }, errorCallback);
    }
    /** @internal */
    _processLoadedUnitInterfaces(data) {
        mobx_1.runInAction(() => {
            data.forEach(unitJson => {
                instances_1.instancehelpers.abstractUnitJsonToInstance(this, unitJson, true);
            });
            data.filter(unitJson => !!unitJson.containerId).forEach(unitJson => {
                const unit = this._units[unitJson.$ID];
                this._resolveContainer(unit, unitJson.containerId);
            });
            this._qualifiedNameCache.addStructureToCache(this.root);
            Object.keys(this._units).forEach(key => this._units[key].resolveByIdReferences());
        });
        this._areUnitInterfacesLoaded = true;
    }
    /** @internal */
    _resolveContainer(unit, containerId) {
        if (!unit) {
            return; // can happen as long as the meta model isn't complete.
        }
        const container = this._units[containerId];
        if (!container) {
            throw new Error("Invalid container ID: " + containerId);
        }
        if (container !== unit) {
            // Project has a self reference container, which is of course very annoying for recursion..
            // add unit to the structural parent in the project tree
            this._addUnitToStructuralParent(unit, container);
        }
    }
    /**
     * Structural units have children (e.g., folders have documents), but in storage the inverse is stored:
     * documents specify in which parent they reside.
     * However, in the SDK we want to be able to read the children of a folder, so these kind of properties are expressed
     * using StructuralChild(List)Property objects, see `properties/structural.ts`.
     * We notify structural parents that a child was added upon loading a child structure,
     * so that parent can do the appropriate bookkeeping at that time (and only once).
     * This way we avoid having to visit all unit interfaces to gather all children of a specific structural child (list) property.
     *
     * @internal
     */
    _addUnitToStructuralParent(unit, parent) {
        if (unit.container !== parent) {
            // old container needs to be unset first
            this._removeUnitFromStructuralParent(unit);
        }
        // set the new parent
        unit._container = parent;
        const prop = parent["__" + unit._containmentName];
        parent._isUpdating = true;
        if (prop instanceof properties_1.StructuralChildProperty) {
            prop.observableValue.set(unit);
        }
        else if (prop instanceof properties_1.StructuralChildListProperty) {
            if (prop.observableValue.indexOf(unit) === -1) {
                prop.observableValue.push(unit);
            }
        }
        else {
            throw new Error("Illegal state");
        }
        parent._isUpdating = false;
    }
    /** @internal */
    _removeUnitFromStructuralParent(unit) {
        if (!unit.container) {
            return;
        }
        const oldParent = unit.container;
        const oldProp = oldParent["__" + unit._containmentName];
        oldParent._isUpdating = true;
        if (oldProp instanceof properties_1.StructuralChildProperty) {
            oldProp.observableValue.set(null);
        }
        else if (oldProp instanceof properties_1.StructuralChildListProperty) {
            oldProp.observableValue.remove(unit);
        }
        else {
            throw new Error("Illegal state");
        }
        oldParent._isUpdating = false;
        unit._container = null;
    }
    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     *
     * @internal
     */
    _processNameChange(structure) {
        if (instances_1.instancehelpers.structureAffectsQualifiedNames(structure)) {
            this._qualifiedNameCache.addStructureToCache(structure);
        }
    }
    /** @internal */
    _addDetachedStructure(structure) {
        if (this.detachedStructures.indexOf(structure) === -1) {
            this.detachedStructures.push(structure);
        }
    }
    /** @internal */
    _removeDetachedStructure(structure) {
        const index = this.detachedStructures.indexOf(structure);
        if (index >= 0) {
            this.detachedStructures.splice(index, 1);
        }
    }
    /** @internal */
    _assertConnectionClosed() {
        if (!this.deltaManager.isClosing) {
            throw new Error("Connection should be closed first");
        }
    }
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    deleteWorkingCopy(callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.deleteWorkingCopy(this.id, callback, errorCallback || this._errorHandler);
    }
    exportMpk(outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportMpk(this.id, outFilePath, callback, errorCallback || this._errorHandler);
    }
    exportModuleMpk(moduleId, outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportModuleMpk(this.id, moduleId, outFilePath, callback, errorCallback || this._errorHandler);
    }
    importModuleMpk(workingCopyId, mpkPath, callback, errorCallback) {
        this._client.importModuleMpk(this.id, mpkPath, callback, errorCallback || this._errorHandler);
    }
    getFilePaths(callback, errorCallback) {
        this.getFiles(callback, errorCallback);
    }
    getFiles(arg1, arg2, arg3) {
        let cb, errorCb, options;
        if (typeof arg1 === "function") {
            cb = arg1;
            errorCb = arg2;
            options = {
                format: "json"
            };
        }
        else {
            options = arg1;
            cb = arg2;
            errorCb = arg3;
        }
        this._client.getFiles(this.id, options, cb, errorCb);
    }
    getFile(filePath, outFilePath, callback, errorCallback) {
        this._client.getFile(this.id, filePath, outFilePath, callback, errorCallback);
    }
    putFile(inFilePath, filePath, callback, errorCallback) {
        this._client.putFile(this.id, inFilePath, filePath, callback, errorCallback);
    }
    deleteFile(filePath, callback, errorCallback) {
        this._client.deleteFile(this.id, filePath, callback, errorCallback);
    }
    getAppEnvironmentStatus(callback, errorCallback) {
        this._client.getAppEnvironmentStatus(this.id, callback, errorCallback);
    }
    getAppUpdateStatus(jobId, callback, errorCallback) {
        this._client.getAppUpdateStatus(this.id, jobId, callback, errorCallback);
    }
    startAppUpdate(callback, errorCallback) {
        this._client.startAppUpdate(this.id, callback, errorCallback);
    }
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.structureTypeName, "Expenses.Expense.Price");`
     *
     * @internal
     */
    _resolveName(structureTypeName, qualifiedName) {
        return this._qualifiedNameCache.resolve(structureTypeName, qualifiedName);
    }
    /** @internal */
    _warnAboutUnsupportedType(propertyName, qname) {
        utils_1.utils.warnOnce(`Cannot resolve identifier; the type of the identifiers used by property '${propertyName}' is currently not supported. `
            + `Please use the property '.${propertyName}QualifiedName' instead to read or update this reference.`);
    }
    /** @internal */
    _allOfTypes(structureTypeNames) {
        return utils_1.utils.flatten(structureTypeNames.map(structureTypeName => this._unitInterfacesByType(structureTypeName)));
    }
    /** @internal */
    onUnitLoaded(callback) {
        this.eventEmitter.on(AbstractModel.UNIT_LOADED, callback);
    }
}
AbstractModel.UNIT_LOADED = "UnitLoaded";
exports.AbstractModel = AbstractModel;
//# sourceMappingURL=abstract-model.js.map