"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
class AbstractProperty {
    constructor(declaredOn, parent, name, ...initializeArgs) {
        this.declaredOn = declaredOn;
        this.parent = parent;
        this.name = name;
        /** @internal */
        this._skipOnChange = false;
        parent._registerProperty(this);
        const initializeResult = this.initialize.apply(this, initializeArgs);
        this.observableValue = initializeResult.observableValue;
        this.disposer = initializeResult.disposer;
    }
    get versionInfo() {
        return this.declaredOn.versionInfo.getPropertyVersionInfo(this.name);
    }
    get isPublic() {
        return this.versionInfo.isPublic.isEnabledIn(this.parent.model.metaModelVersion);
    }
    get isRequired() {
        return this.versionInfo.isRequired.isEnabledIn(this.parent.model.metaModelVersion);
    }
    /**
     * Returns true if this property is not deleted, and already availabe in the current model version.
     */
    get isAvailable() {
        return this.versionInfo.availability.isAvailableIn(this.parent.model.metaModelVersion);
    }
    /** @internal */
    shouldHandleChange() {
        return !this.parent._isUpdating && !this._skipOnChange;
    }
    /** @internal */
    assertWritable() {
        this.parent._assertLoaded(this);
        if (this.parent._isDeleted) {
            throw new Error("Cannot write properties of deleted element");
        }
        this.assertPropertyAvailableInCurrentVersion();
    }
    /** @internal */
    assertReadable() {
        if (!this.isPublic) {
            this.parent._assertLoaded(this);
        }
        this.assertPropertyAvailableInCurrentVersion();
    }
    /** @internal */
    assertPropertyAvailableInCurrentVersion() {
        // parent check is done here and not in property info, because the actual type of the structure
        // might have different version annations as the type that declared the property
        this.parent.versionInfo.checkStructureVersion(this.parent, true);
        this.versionInfo.checkPropertyVersion(this, true);
    }
    dispose() {
        if (this.disposer) {
            this.disposer();
        }
    }
}
exports.AbstractProperty = AbstractProperty;
//# sourceMappingURL=abstract-property.js.map