"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
/**
 * Default implementation of {@link IModelServerClient}.
 */
const apiEndPoint = "/api/v1/";
class ModelServerClientImpl {
    constructor(transportation) {
        this.transportation = transportation;
        this.pendingRequests = [];
        this.MAX_PARALLEL_REQUESTS = 100;
        this.runningRequests = 0;
    }
    getHeadersForModificationRequest() {
        if (this.editLockId) {
            return { "Edit-Lock-Id": this.editLockId };
        }
        return undefined;
    }
    createWorkingCopy(workingCopyInfo, callback, errorCallback) {
        const data = {
            workingCopyId: workingCopyInfo.workingCopyId || "",
            name: workingCopyInfo.name,
            description: workingCopyInfo.description || "",
            avatarUrl: workingCopyInfo.avatarUrl || "",
            projectId: workingCopyInfo.projectId || "",
            longLived: workingCopyInfo.longLived === true,
            teamServerBaseRevision: workingCopyInfo.teamServerBaseRevision || -1,
            teamServerBaseBranch: workingCopyInfo.teamServerBaseBranch || "",
            setAsDefault: workingCopyInfo.setAsDefault === true
        };
        this.transportation.requestMultipartBinaryFileUpload({
            method: "post",
            url: `${apiEndPoint}wc/`,
            body: data,
            fileParameterName: "template",
            fileName: workingCopyInfo.template
        }, callback, errorCallback);
    }
    loadWorkingCopyMetaData(workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "get", url: `${apiEndPoint}wc/${workingCopyId}` }, callback, errorCallback);
    }
    loadUnitInterfaces(workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "get", url: `${apiEndPoint}wc/${workingCopyId}/units/` }, callback, errorCallback);
    }
    deleteWorkingCopy(workingCopyId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: `${apiEndPoint}wc/${workingCopyId}` }, callback, errorCallback);
    }
    grantAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "put", url: `${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}` }, callback, errorCallback);
    }
    revokeAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: `${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}` }, callback, errorCallback);
    }
    checkAccess(workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}`
        }, (response) => {
            return void callback(response.hasAccess);
        }, errorCallback);
    }
    grantAccessByProject(projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "put", url: `${apiEndPoint}project/${projectId}/members/${encodeURIComponent(memberOpenId)}` }, callback, errorCallback);
    }
    revokeAccessByProject(projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: `${apiEndPoint}project/${projectId}/members/${encodeURIComponent(memberOpenId)}` }, callback, errorCallback);
    }
    exportMpk(workingCopyId, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/mpk`
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    }
    exportModuleMpk(workingCopyId, moduleId, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/module/${moduleId}/mpk`
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    }
    importModuleMpk(workingCopyId, mpkPath, callback, errorCallback) {
        this.transportation.requestMultipartBinaryFileUpload({
            method: "post",
            url: `${apiEndPoint}wc/${workingCopyId}/module`,
            fileParameterName: "mpk",
            fileName: mpkPath
        }, callback, errorCallback);
    }
    startAppUpdate(workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "post",
            url: `${apiEndPoint}wc/${workingCopyId}/updateapp`
        }, (status) => {
            this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    }
    getAppUpdateStatus(workingCopyId, jobId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/updateapp-status?jobid=${jobId}`
        }, (status) => {
            this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    }
    loadUnitById(workingCopyId, unitId, callback, errorCallback) {
        this.loadUnitByIdBatched({ workingCopyId, unitId, callback, errorCallback });
    }
    filterUnitsByCustomWidgetId(workingCopyId, widgetId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/units/filter/custom-widget?widgetId=${widgetId}`
        }, callback, errorCallback);
    }
    sendDeltas(workingCopyId, deltas, callback, errorCallback) {
        this.transportation.request({
            method: "post",
            url: `${apiEndPoint}wc/${workingCopyId}/deltas`,
            headers: this.getHeadersForModificationRequest(),
            body: { deltas: deltas }
        }, callback, errorCallback);
    }
    getFiles(workingCopyId, options, callback, errorCallback) {
        if (!options.format) {
            options.format = "json";
        }
        const filterPostfix = options.filter ? "&filter=" + options.filter : "";
        const downloadUrl = `${apiEndPoint}wc/${workingCopyId}/files/?format=${options.format}${filterPostfix}`;
        if (options.format === "json") {
            this.transportation.request({ method: "get", url: downloadUrl }, callback, errorCallback);
        }
        else if (options.format === "zip") {
            this.transportation.requestFileDownload({
                method: "get",
                url: downloadUrl
            }, this.createDownloadHandler(options.path, callback, errorCallback), errorCallback);
        }
        else {
            throw new Error("Unsupported format" + options.format);
        }
    }
    getFile(workingCopyId, filePath, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`
        }, this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    }
    putFile(workingCopyId, inFilePath, filePath, callback, errorCallback) {
        this.transportation.requestMultipartBinaryFileUpload({
            method: "put",
            url: `${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`,
            headers: this.getHeadersForModificationRequest(),
            fileParameterName: "file",
            fileName: inFilePath
        }, callback, errorCallback);
    }
    deleteFile(workingCopyId, filePath, callback, errorCallback) {
        this.transportation.request({
            method: "delete",
            url: `${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`,
            headers: this.getHeadersForModificationRequest()
        }, callback, errorCallback);
    }
    getAppEnvironmentStatus(workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}wc/${workingCopyId}/app-environment-status`,
            longTimeout: true
        }, this.handleRawDeploymentResult.bind(this, callback, errorCallback), errorCallback);
    }
    getMyWorkingCopies(callback, errorCallback) {
        this.transportation.request({ method: "get", url: `${apiEndPoint}wc/` }, callback, errorCallback);
    }
    getWorkingCopyByProject(projectId, callback, errorCallback) {
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}project/${projectId}`
        }, (response) => {
            return void callback(response.workingCopyId);
        }, errorCallback);
    }
    createWorkingCopyByProject(projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "post",
            url: `${apiEndPoint}project/${projectId}`,
            body: {
                projectId: projectId,
                workingCopyId: workingCopyId
            }
        }, callback, errorCallback);
    }
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    updateWorkingCopyByProject(projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request({
            method: "put",
            url: `${apiEndPoint}project/${projectId}`,
            body: {
                projectId: projectId,
                workingCopyId: workingCopyId
            }
        }, callback, errorCallback);
    }
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    deleteWorkingCopyByProject(projectId, callback, errorCallback) {
        this.transportation.request({ method: "delete", url: `${apiEndPoint}project/${projectId}` }, callback, errorCallback);
    }
    lockWorkingCopy(workingCopyId, lockOptionsOrCallback, callbackOrErrorCallback, errorCallback) {
        let callback;
        let lockOptions;
        if (typeof lockOptionsOrCallback === "function") {
            callback = lockOptionsOrCallback;
            errorCallback = callbackOrErrorCallback;
            lockOptions = { lockType: "bidi" };
        }
        else if (typeof lockOptionsOrCallback === "string") {
            lockOptions = { lockType: lockOptionsOrCallback };
            callback = callbackOrErrorCallback;
        }
        else {
            lockOptions = lockOptionsOrCallback;
            callback = callbackOrErrorCallback;
        }
        if (lockOptions.lockType === "edit") {
            this.editLockId = lockOptions.lockId;
        }
        this.transportation.request({
            method: "post",
            url: `${apiEndPoint}wc/${workingCopyId}/lock`,
            body: lockOptions
        }, callback, errorCallback);
    }
    unlockWorkingCopy(workingCopyId, callback, errorCallback) {
        this.editLockId = undefined;
        this.transportation.request({ method: "post", url: `${apiEndPoint}wc/${workingCopyId}/unlock` }, callback, errorCallback);
    }
    parseAppUpdateStatus(status) {
        Object.assign(status, this.parseBuildStatus(status.buildstatus));
    }
    sendGetUnitRequest(info) {
        this.runningRequests += 1;
        this.transportation.request({
            method: "get",
            url: `${apiEndPoint}wc/${info.workingCopyId}/units/${info.unitId}`
        }, (data) => {
            this.completeGetUnitRequest();
            return void info.callback(data);
        }, error => {
            this.completeGetUnitRequest();
            return void info.errorCallback(error);
        });
    }
    createDownloadHandler(exportPath, callback, errorCallback) {
        if (exportPath && !fs) {
            throw new Error("cannot download asset to disk without file system");
        }
        return (response) => {
            if (exportPath) {
                this.storeResponseAsFile(response, exportPath, () => void callback(null), errorCallback);
            }
            else {
                callback(response);
            }
        };
    }
    handleRawDeploymentResult(callback, errorCallback, deploymentResult) {
        callback(Object.assign(deploymentResult, this.parseBuildStatus(deploymentResult.buildstatus)));
    }
    parseBuildStatus(buildstatus) {
        // EPO: JSON to object conversion done here, and not earlier in the chain (like in platform-services or in the model-server)
        // because we will skip platform-services and model-server in a later story.
        try {
            if (!buildstatus) {
                return { buildErrors: [], consistencyErrors: [] };
            }
            const parsedBuildstatus = JSON.parse(buildstatus);
            parsedBuildstatus.errors.forEach((error) => { error.severity = "Error"; });
            return {
                buildErrors: parsedBuildstatus.errors,
                consistencyErrors: parsedBuildstatus.problems
            };
        }
        catch (e) {
            console.error("Failed to parse deployment result: " + buildstatus);
            return {
                buildErrors: [{
                        severity: "Error",
                        message: "Failed to build.",
                        details: buildstatus
                    }],
                consistencyErrors: []
            };
        }
    }
    storeResponseAsFile(response, outFilePath, callback, errorCallback) {
        const dirPath = path.dirname(outFilePath);
        fs.lstat(dirPath, (err, stats) => {
            if (err || !stats.isDirectory()) {
                const cwd = process.cwd();
                errorCallback(new Error(`target directory ${dirPath} does not exist relative to ${cwd}`));
                return;
            }
            fs.open(outFilePath, "w", (err2, fd) => {
                if (err2) {
                    errorCallback(new Error(`Could not create file with path "${outFilePath}"; due to: ${err2}`));
                    return;
                }
                fs.writeFile(outFilePath, response, { encoding: "binary" }, err3 => {
                    if (err3) {
                        errorCallback(new Error(`Could not write to file with path "${outFilePath}"; due to: ${err3}`));
                        return;
                    }
                    callback(); // make sure we don't expose any arguments to the end-user
                });
            });
        });
    }
    loadUnitByIdBatched(info) {
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS) {
            this.sendGetUnitRequest(info);
        }
        else {
            this.pendingRequests.push(info);
        }
    }
    completeGetUnitRequest() {
        this.runningRequests -= 1;
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS && this.pendingRequests.length > 0) {
            this.sendGetUnitRequest(this.pendingRequests.shift());
        }
    }
}
exports.ModelServerClientImpl = ModelServerClientImpl;
//# sourceMappingURL=model-server-client.js.map